name: Deploy Infrastructure

on:
  pull_request:
    types: [closed]
    branches: [main]
    paths:
      - 'terraform/environments/**'
      - 'backend/terraform/environments/**'

jobs:
  deploy:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    env:
      API_URL: ${{ secrets.API_URL }}          # e.g. https://b5c78943d402.ngrok-free.app
      API_TOKEN: ${{ secrets.API_TOKEN }}      # optional, used as Bearer token if set
      AWS_REGION: us-east-1

    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Detect changed tfvars
        id: detect
        run: |
          set -euo pipefail
          echo "Trying HEAD~1..HEAD diff; falling back to origin/main if needed"
          changed=$(git diff --name-only HEAD~1 HEAD || true)
          if [ -z "$changed" ]; then
            git fetch origin main --depth=1 || git fetch origin main
            changed=$(git diff --name-only origin/main HEAD || true)
          fi

          # filter for env aws requests tfvars (both repo layouts)
          tfvars_files=$(printf "%s\n" "$changed" | grep -E '(^|/)(environments/aws|backend/terraform/environments/aws)/[^/]+/requests/[^/]+\.tfvars$' || true)

          echo "all_changed<<EOF" >> $GITHUB_OUTPUT
          printf "%s\n" "$changed" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          if [ -z "$tfvars_files" ]; then
            echo "no_tfvars=true" >> $GITHUB_OUTPUT
            echo "tfvars_match=" >> $GITHUB_OUTPUT
            echo "environment=" >> $GITHUB_OUTPUT
            echo "request_id=" >> $GITHUB_OUTPUT
            echo "::warning::No tfvars change detected â€” skipping deploy."
            exit 0
          fi

          # pick first
          tfvars_file=$(printf "%s\n" "$tfvars_files" | head -n1 | sed 's#^\./##')

          # extract environment & request id from either possible path
          if [[ "$tfvars_file" =~ environments/aws/([^/]+)/requests/([^/]+)\.tfvars$ ]]; then
            environment=${BASH_REMATCH[1]}
            request_id=${BASH_REMATCH[2]}
          elif [[ "$tfvars_file" =~ backend/terraform/environments/aws/([^/]+)/requests/([^/]+)\.tfvars$ ]]; then
            environment=${BASH_REMATCH[1]}
            request_id=${BASH_REMATCH[2]}
          else
            echo "::error::Could not parse environment/request id from: $tfvars_file"
            echo "no_tfvars=true" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "no_tfvars=false" >> $GITHUB_OUTPUT
          echo "tfvars_match=$tfvars_file" >> $GITHUB_OUTPUT
          echo "environment=$environment" >> $GITHUB_OUTPUT
          echo "request_id=$request_id" >> $GITHUB_OUTPUT

      - name: Deploy (plan & apply)
        if: steps.detect.outputs.no_tfvars == 'false' && steps.detect.outputs.request_id != ''
        run: |
          set -euo pipefail
          environment="${{ steps.detect.outputs.environment }}"
          request_id="${{ steps.detect.outputs.request_id }}"
          tfvars="${{ steps.detect.outputs.tfvars_match }}"

          echo "Request: $request_id"
          echo "Environment: $environment"
          echo "Using tfvars: $tfvars"

          # choose base depending on which layout the tfvars path uses
          if [[ "$tfvars" == backend/terraform/* ]]; then
            base="backend/terraform/environments/aws/$environment"
            tfvars_rel="requests/${request_id}.tfvars"
          else
            base="terraform/environments/aws/$environment"
            tfvars_rel="requests/${request_id}.tfvars"
          fi

          if [ ! -d "$base" ]; then
            echo "::error::Terraform environment directory not found: $base"
            ls -la "$(dirname "$tfvars")" || true
            exit 1
          fi

          cd "$base"

          if [ ! -f "$tfvars_rel" ]; then
            echo "::error::tfvars file not found at $tfvars_rel relative to $base"
            echo "Abs candidate: $(pwd)/$tfvars_rel"
            exit 1
          fi

          echo "Initializing Terraform..."
          terraform init -input=false

          echo "Planning..."
          # detailed-exitcode: 0=no changes, 2=changes, 1=error
          set +e
          terraform plan -var-file="$tfvars_rel" -out=tfplan -detailed-exitcode
          rc=$?
          set -e
          if [ "$rc" -eq 1 ]; then
            echo "::error::terraform plan failed (exit code 1)"
            terraform plan -var-file="$tfvars_rel" || true
            exit 1
          fi

          if [ "$rc" -eq 0 ]; then
            echo "No changes to apply (terraform plan exit code 0). Exiting."
            exit 0
          fi

          # rc == 2 -> changes present
          echo "Applying changes..."
          terraform apply -auto-approve tfplan

      - name: Collect outputs & state (on success)
        if: success() && steps.detect.outputs.no_tfvars == 'false' && steps.detect.outputs.request_id != ''
        id: collect
        run: |
          set -euo pipefail
          environment="${{ steps.detect.outputs.environment }}"
          request_id="${{ steps.detect.outputs.request_id }}"
          tfvars="${{ steps.detect.outputs.tfvars_match }}"

          # determine base dir again
          if [[ "$tfvars" == backend/terraform/* ]]; then
            base="backend/terraform/environments/aws/$environment"
          else
            base="terraform/environments/aws/$environment"
          fi

          cd "$base"

          # outputs as JSON
          terraform output -json > outputs.json || echo "{}" > outputs.json

          # pull state
          terraform state pull > state.tfstate || echo "{}" > state.tfstate

          # record paths (absolute) for later upload
          echo "outputs_file=$(pwd)/outputs.json" >> $GITHUB_OUTPUT
          echo "state_file=$(pwd)/state.tfstate" >> $GITHUB_OUTPUT

          # find tfvars absolute path relative to repo root
          repo_root=$(git rev-parse --show-toplevel)
          echo "tfvars_abs=$repo_root/$tfvars" >> $GITHUB_OUTPUT
          echo "tfvars_repo_path=$tfvars" >> $GITHUB_OUTPUT

      - name: Notify backend (deployment success)
        if: success() && steps.detect.outputs.no_tfvars == 'false' && steps.detect.outputs.request_id != ''
        continue-on-error: true
        env:
          API_URL: ${{ env.API_URL }}
          API_TOKEN: ${{ env.API_TOKEN }}
        run: |
          set -euo pipefail
          request_id="${{ steps.detect.outputs.request_id }}"
          environment="${{ steps.detect.outputs.environment }}"
          outputs_file="${{ steps.collect.outputs.outputs_file }}"
          tfvars_repo_path="${{ steps.collect.outputs.tfvars_repo_path }}"

          api_url="${API_URL%/}"
          notify_endpoint="$api_url/infrastructure/notify-deployment"

          # read outputs (JSON)
          outputs_json=$(cat "$outputs_file" || echo "{}")

          # build payload with jq
          body=$(jq -n \
            --arg r "$request_id" \
            --arg e "$environment" \
            --arg t "$tfvars_repo_path" \
            --argjson o "$outputs_json" \
            '{
              "request_id": $r,
              "environment": $e,
              "tfvars": $t,
              "outputs": $o
            }'
          )

          echo "Posting deployment notification to $notify_endpoint"
          headers=(-H "Content-Type: application/json")
          if [ -n "$API_TOKEN" ]; then
            headers+=(-H "Authorization: Bearer $API_TOKEN")
          fi

          curl --fail -sS "${headers[@]}" -X POST "$notify_endpoint" -d "$body" || {
            echo "Warning: notify-deployment request failed"
            exit 0
          }

      - name: Upload terraform files to backend
        if: success() && steps.detect.outputs.no_tfvars == 'false' && steps.detect.outputs.request_id != ''
        continue-on-error: true
        env:
          API_URL: ${{ env.API_URL }}
          API_TOKEN: ${{ env.API_TOKEN }}
        run: |
          set -euo pipefail
          request_id="${{ steps.detect.outputs.request_id }}"
          environment="${{ steps.detect.outputs.environment }}"
          outputs_file="${{ steps.collect.outputs.outputs_file }}"
          state_file="${{ steps.collect.outputs.state_file }}"
          tfvars_abs="${{ steps.collect.outputs.tfvars_abs }}"

          api_url="${API_URL%/}"
          upload_endpoint="$api_url/infrastructure/upload-terraform"

          echo "Uploading Terraform files to backend:"
          echo "  State: $state_file"
          echo "  Outputs: $outputs_file"
          echo "  Tfvars: $tfvars_abs"

          # Ensure files exist (if not, sensors have already created placeholders)
          [ -f "$state_file" ] || { echo "State file not found"; exit 0; }
          [ -f "$outputs_file" ] || { echo "Outputs file not found"; exit 0; }
          [ -f "$tfvars_abs" ] || { echo "Tfvars file not found"; exit 0; }

          headers=()
          if [ -n "$API_TOKEN" ]; then
            headers+=(-H "Authorization: Bearer $API_TOKEN")
          fi

          curl --fail -sS "${headers[@]}" \
            -F "request_id=$request_id" \
            -F "environment=$environment" \
            -F "state_file=@$state_file" \
            -F "outputs_file=@$outputs_file" \
            -F "tfvars_file=@$tfvars_abs" \
            "$upload_endpoint" || {
              echo "Warning: upload-terraform request failed"
              exit 0
            }

      - name: Notify backend (failure)
        if: failure() && steps.detect.outputs.no_tfvars == 'false' && steps.detect.outputs.request_id != ''
        continue-on-error: true
        env:
          API_URL: ${{ env.API_URL }}
          API_TOKEN: ${{ env.API_TOKEN }}
        run: |
          set -euo pipefail
          request_id="${{ steps.detect.outputs.request_id }}"
          environment="${{ steps.detect.outputs.environment }}"
          api_url="${API_URL%/}"
          notify_endpoint="$api_url/infrastructure/notify-deployment-failed"

          # Capture some logs (if jq not available for heavy JSON use, send simple body)
          log_excerpt="Terraform run failed. See GitHub Actions logs."

          body=$(jq -n \
            --arg r "$request_id" \
            --arg e "$environment" \
            --arg m "$log_excerpt" \
            '{
              "request_id": $r,
              "environment": $e,
              "message": $m
            }'
          )

          headers=(-H "Content-Type: application/json")
          if [ -n "$API_TOKEN" ]; then
            headers+=(-H "Authorization: Bearer $API_TOKEN")
          fi

          curl --fail -sS "${headers[@]}" -X POST "$notify_endpoint" -d "$body" || {
            echo "Warning: notify-deployment-failed request failed"
            exit 0
          }

      - name: Finish
        run: echo "Deployment workflow completed"

